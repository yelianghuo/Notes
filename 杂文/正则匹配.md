
正则匹配
====
理论
--------
正则表达式由常量和算子组成，它们分别指示字符串的集合和在这些集合上的运算
    
    字符串的集合: 即在正则匹配中基本的字符串集
    集合上的运算: 即用*.?+这些特殊符号扩展基本字符串集来进行抽象匹配


正则匹配的基本概念
------
* `.`: 匹配除了`\n`以外的任何单个字符
* `*`: 匹配前面的子表达式零次或多次
* `+`: 匹配前面的子表达式一次或多次
* `?`: 匹配前面的子表达式零次或一次
* `{n}`: n是一个非负整数。匹配确定的n次。例如，`o{2}`不能匹配`Bob`中的`o`，但是能匹配`food`中的两个o。
* `{n,}`: n是一个非负整数。至少匹配n次。例如，`o{2,}`不能匹配`Bob`中的`o`，但能匹配`foooood`中的所有o。`o{1,}`等价于`o+`。`o{0,}`则等价于`o*`
* `{n,m}`: m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，`o{1,3}`将匹配`fooooood`中的前三个o。`o{0,1}`等价于`o?`。请注意在逗号和两个数之间不能有空格。
* `?`: 非贪心量化（Non-greedy quantifiers），当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。

* `(pattern)`: 匹配pattern并保留这一匹配的子字符串(从1开始)。该子字符串用于向后引用`(\num)`。
* `(?:pattern)`: 匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。
* `(?=pattern)`: 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，`Windows(?=95|98|NT|2000)`能匹配`Windows2000`中的`Windows`，但不能匹配`Windows3.1`中的`Windows`。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
* `(?!pattern)`: 正向否定预查（negative assert），在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如`Windows(?!95|98|NT|2000)`能匹配`Windows3.1`中的`Windows`，但不能匹配`Windows2000`中的`Windows`。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
* `(?<=pattern)`: 反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，`(?<=95|98|NT|2000)Windows`能匹配`2000Windows`中的`Windows`，但不能匹配`3.1Windows`中的`Windows`
* `(?<!pattern)`: 反向否定预查，与正向否定预查类似，只是方向相反。例如`(?<!95|98|NT|2000)Windows`能匹配`3.1Windows`中的`Windows`，但不能匹配`2000Windows`中的`Windows`

* `x|y`: 匹配x或y。例如，`z|food`能匹配`z`或`food`，`(?:z|f)ood`则匹配`zood`或`food`
* `[xyz]`: 字符集合,匹配所包含的任意一个字符
* `[^xyz]`: 排除型字符集合，匹配未列出的任意字符
* `[a-z]`: 	字符范围，匹配指定范围内的任意字符；例如，`[a-z]`可以匹配`a`到`z`范围内的任意小写字母字符
* `[^a-z]`: 排除型的字符范围，匹配任何不在指定范围内的任意字符

* `\b`: 匹配一个单词边界，也就是指单词和空格间的位置；例如，`er\b`可以匹配`never`中的`er`，但不能匹配`verb`中的`er` 
* `\B`: 匹配非单词边界，`er\B`能匹配`verb`中的`er`，但不能匹配`never`中的`er`
* `\w`: 匹配包括下划线的任何单词字符。等价于`[A-Za-z0-9_]`
* `\W`: 匹配任何非单词字符。等价于`[^A-Za-z0-9_]`
* `\d`: 匹配一个数字字符，等价于`[0-9]`
* `\S`: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]
* `\s`: 匹配任何非空白字符。等价于`[^ \f\n\r\t\v]`


**获取匹配**  
是指系统会在幕后将所有的子模式匹配结果保存起来，供我们查找或者替换。如后向引用的使用

**非获取匹配**  
这时系统并不会保存子模式的匹配结果，子模式的匹配更多的只是作为一种限制条件使用，如正向预查，反向预查，负正向预查，负反向预查等

**后向引用**  
使用`\数字`代表前面某个子模式的匹配内容

正则匹配示例
----
**下述样例来自18年网易秋招笔试**   
``` 
**问题:**字符串: `<img src="http://www.wangyi.com"></img>`  
* A: `<img src="[."]*"></img>`
* B: `<img src="[^"]*"></img>`
**anwser:** B,在`[.]`表示`.`这个符号，因此A是匹配不上的
```
**下述样例展示(pattern)保存当前匹配的字符串与向后引用**  
``` 
Text: 
<h1>This is a valid header</h1>
<h2>This is not valid.</h3>
RegEx: 
<h([1-6])>.*?</h\1>
Result: 
<h1>This is a valid header</h1> 
```
**（*,+,?，{n}，{n,}，{n,m}）这些匹配字符默认是贪心匹配**    
``` 
Text:                                                            
oooo
RegEx:                       RegEx：
o*?                          o*                       
Result: 
匹配到5个，但是都为空            oooo 
```
**uuid的正则**  
```
uuid: [A-Fa-f0-9]{8}-(?:[A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}
```
*其他的正则可以参考elk中的部分例子[elk生态圈](http://grokdebug.herokuapp.com/patterns#)*
